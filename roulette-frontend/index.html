<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Telegram Roulette</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root {
      --bg-color: #1c1c1e;
      --ticket-bg: #2c2c2e;
      --highlight-color: #007aff;
      --text-color: #ffffff;
      --ticket-width: 90px;
      --ticket-height: 80px;
      --gap: 10px;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }

    h1 {
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: 600;
    }

    .roulette-container {
      position: relative;
      width: 320px;
      height: 300px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      gap: 5px;
      /* Mask to fade out top and bottom */
      mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
      -webkit-mask-image: linear-gradient(to bottom, transparent, black 20%, black 80%, transparent);
    }

    .roulette-track {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--gap);
      will-change: transform;
      width: var(--ticket-width);
    }

    .ticket {
      width: var(--ticket-width);
      height: var(--ticket-height);
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      flex-shrink: 0;
    }

    .ticket-amount {
      font-size: 20px;
      font-weight: 800;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ticket-label {
      font-size: 12px;
      opacity: 0.9;
      margin-top: 2px;
    }

    /* Different colors for variety */
    .ticket:nth-child(3n+1) {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .ticket:nth-child(3n+2) {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .ticket:nth-child(3n+3) {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    }

    /* Center indicator line */
    .indicator-line {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 2px;
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-50%);
      z-index: 10;
      pointer-events: none;
    }

    .spin-btn {
      margin-top: 30px;
      padding: 16px 40px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
    }

    .spin-btn:active {
      transform: scale(0.95);
    }

    .spin-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }

    #result-message {
      margin-top: 15px;
      height: 24px;
      font-size: 16px;
      color: #888;
    }
  </style>
</head>

<body>

  <h1>Slot Machine</h1>

  <div class="roulette-container">
    <div class="indicator-line"></div>

    <div class="roulette-track" id="track1"></div>
    <div class="roulette-track" id="track2"></div>
    <div class="roulette-track" id="track3"></div>
  </div>

  <div id="result-message">–ò—Å–ø—ã—Ç–∞–π —É–¥–∞—á—É!</div>
  <button class="spin-btn" onclick="spin()" id="spinBtn">–ö—Ä—É—Ç–∏—Ç—å</button>

  <script>
    const tg = window.Telegram.WebApp;
    tg.expand();

    const tracks = [
      document.getElementById('track1'),
      document.getElementById('track2'),
      document.getElementById('track3')
    ];
    const spinBtn = document.getElementById('spinBtn');
    const resultMsg = document.getElementById('result-message');

    // Configuration
    const TICKET_HEIGHT = 80;
    const GAP = 10;
    const ITEM_SIZE = TICKET_HEIGHT + GAP;

    // Symbols (Removed Empty, added 0.5/1)
    const SYMBOLS = [
      { label: "100", value: 100 },
      { label: "50", value: 50 },
      { label: "20", value: 20 },
      { label: "10", value: 10 },
      { label: "5", value: 5 },
      { label: "1", value: 1 },
      { label: "0.5", value: 0.5 }
    ];

    function createTicket(symbol) {
      const el = document.createElement('div');
      el.className = 'ticket';
      el.innerHTML = `
        <div class="ticket-amount">${symbol.label}</div>
        <div class="ticket-label">USDT</div>
      `;
      return el;
    }

    function initTrack(trackIndex) {
      const track = tracks[trackIndex];
      track.innerHTML = '';
      // Create initial set of items
      for (let i = 0; i < 30; i++) {
        const sym = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
        track.appendChild(createTicket(sym));
      }

      // Center initially on Index 2
      // Formula: TranslateY = 110 - (Index * 90)
      // We want to simulate "Falling", so we want to be at the "Bottom" of the list?
      // No, if we are at the bottom, we can't scroll down further easily without appending.
      // Let's stick to the plan: View Index 2.
      const startItemIndex = 2;
      const offset = 110 - (startItemIndex * ITEM_SIZE);
      track.style.transform = `translateY(${offset}px)`;
    }

    // Init all tracks
    tracks.forEach((_, i) => initTrack(i));

    async function spin() {
      if (spinBtn.disabled) return;
      spinBtn.disabled = true;
      resultMsg.innerText = "–ö—Ä—É—Ç–∏–º...";

      try {
        // 1. Get result from backend
        const res = await fetch("/spin", { method: "POST" });
        const data = await res.json();
        const reelValues = data.reels; // [v1, v2, v3]
        const totalWin = data.total_label;

        // 2. Animate each track
        const animations = tracks.map((track, i) => {
          return new Promise(resolve => {
            // Delay start for sequential effect
            setTimeout(() => {
              const targetValue = reelValues[i];

              // To animate DOWN (falling), we need to move from a High Negative Offset (showing items far down the list? No.)
              // We want to move from "Above" to "Center".
              // Visual: Items fall from top.
              // This means we are currently looking at Index X.
              // We want to look at Index Y, where Y < X?
              // No, if we look at Y < X, we move the strip DOWN.
              // Example: View Index 50. Transform = -4000.
              // View Index 2. Transform = -100.
              // Animation: -4000 -> -100. Strip moves DOWN. Items appear to fall.
              // So we need to generate a strip where the Winner is at Index 2 (Top).
              // And we start viewing at Index 50 (Bottom).

              // 1. Clear and rebuild track
              track.innerHTML = '';
              track.style.transition = 'none';

              // 2. Generate the strip
              // [Winner, Buffer x 2] -> These are at the top (Index 0, 1, 2...)
              // Wait, if Winner is at Index 2.
              // [Buffer, Buffer, Winner, Dummy... Dummy]

              // Let's build it:
              // Index 0: Buffer
              // Index 1: Buffer
              // Index 2: WINNER
              // Index 3..N: Dummies

              const bufferTop = [];
              for (let k = 0; k < 2; k++) bufferTop.push(SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]);

              let winSym = SYMBOLS.find(s => s.value === targetValue);
              if (!winSym) winSym = { label: targetValue.toString(), value: targetValue };

              const dummies = [];
              const spinCount = 30 + (i * 10); // Distance to fall
              for (let k = 0; k < spinCount; k++) dummies.push(SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]);

              // Append to DOM in order:
              // We want Index 0 at top.
              // So append Buffer, then Winner, then Dummies.

              bufferTop.forEach(s => track.appendChild(createTicket(s)));

              const winTicket = createTicket(winSym);
              winTicket.style.border = "2px solid #fff";
              track.appendChild(winTicket);

              dummies.forEach(s => track.appendChild(createTicket(s)));

              // 3. Set Initial Position (Viewing Dummies at the bottom)
              // We want to view Index = (2 + spinCount) roughly?
              // Let's say we view the last dummy.
              const startIndex = 2 + spinCount - 2; // A bit up from bottom
              const startOffset = 110 - (startIndex * ITEM_SIZE);
              track.style.transform = `translateY(${startOffset}px)`;

              // Force reflow
              track.offsetHeight;

              // 4. Animate to Winner (Index 2)
              const targetIndex = 2;
              const targetOffset = 110 - (targetIndex * ITEM_SIZE);

              track.style.transition = `transform ${3 + i}s cubic-bezier(0.1, 0.9, 0.2, 1)`;
              track.style.transform = `translateY(${targetOffset}px)`;

              // Resolve after animation roughly ends
              setTimeout(resolve, (3 + i) * 1000);

            }, i * 500); // Start delay
          });
        });

        await Promise.all(animations);

        resultMsg.innerText = `üéâ –í—ã–ø–∞–ª–æ: ${totalWin}`;
        spinBtn.disabled = false;
        tg.HapticFeedback.notificationOccurred('success');

      } catch (e) {
        console.error(e);
        resultMsg.innerText = "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏";
        spinBtn.disabled = false;
      }
    }
  </script>

</body>

</html>